From 91a112d16409a768e6a361b434caf4c419479d4c Mon Sep 17 00:00:00 2001
From: Adam Thayer <user@biticus.net>
Date: Wed, 12 Sep 2018 11:44:00 -0700
Subject: [PATCH] Fix 32-bit Variable Offset Issues with CoreFoundation

_CFInfo Assumes a 64-bit _cfinfoa type, when it is really 32-bit on 32-bit systems.
_NSCFType assumes a 32-bit _cfinfoa too, making things even more complicated.

There's a couple approaches to addressing this:
1) Back _CFInfo with a UInt that, on paper, matches size with __CFInfoType
2) Add padding so we can guarantee that _CFInfo can always be 64-bit.

Which one you pick depends on if this is guaranteed to be true: UInt == __CFInfoType

Because Android has some interesting macros in the code, this change picks option 2, even though it
does mean an extra 4 bytes for each bridgable object.

In either case, it makes sense that _NSCFType should be backed by a _CFInfo instead
of a raw int type. Share types when possible so we have consistent, understandable behavior.
---
 CoreFoundation/Base.subproj/CFRuntime.h  | 5 +++--
 CoreFoundation/String.subproj/CFString.h | 1 +
 Foundation/NSSwiftRuntime.swift          | 4 ++--
 3 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/CoreFoundation/Base.subproj/CFRuntime.h b/CoreFoundation/Base.subproj/CFRuntime.h
index 13b044c2..bff10ced 100644
--- a/CoreFoundation/Base.subproj/CFRuntime.h
+++ b/CoreFoundation/Base.subproj/CFRuntime.h
@@ -194,18 +194,19 @@ typedef struct __CFRuntimeBase {
     // This matches the isa and retain count storage in Swift
     uintptr_t _cfisa;
     uintptr_t _swift_rc;
-    // This is for CF's use, and must match _NSCFType layout
+    // This is for CF's use, and must match _CFInfo layout
 #if defined(__LP64__) || defined(__LLP64__)
     _Atomic(uint64_t) _cfinfoa;
 #else
     _Atomic(uint32_t) _cfinfoa;
+    uint32_t          _padding;
 #endif
 } CFRuntimeBase;
 
 #if defined(__LP64__) || defined(__LLP64__)
 #define INIT_CFRUNTIME_BASE(...) {0, _CF_CONSTANT_OBJECT_STRONG_RC, 0x0000000000000080ULL}
 #else
-#define INIT_CFRUNTIME_BASE(...) {0, _CF_CONSTANT_OBJECT_STRONG_RC, 0x00000080UL}
+#define INIT_CFRUNTIME_BASE(...) {0, _CF_CONSTANT_OBJECT_STRONG_RC, 0x00000080UL, 0}
 #endif
 
 #else
diff --git a/CoreFoundation/String.subproj/CFString.h b/CoreFoundation/String.subproj/CFString.h
index 3eab99a1..0730ec61 100644
--- a/CoreFoundation/String.subproj/CFString.h
+++ b/CoreFoundation/String.subproj/CFString.h
@@ -160,6 +160,7 @@ struct __CFConstStr {
         uint64_t _cfinfoa;
 #else
         uint32_t _cfinfoa;
+        uint32_t _padding;
 #endif
     } _base;
     uint8_t *_ptr;
diff --git a/Foundation/NSSwiftRuntime.swift b/Foundation/NSSwiftRuntime.swift
index 6d3c8527..7d8db725 100644
--- a/Foundation/NSSwiftRuntime.swift
+++ b/Foundation/NSSwiftRuntime.swift
@@ -87,11 +87,11 @@ extension ObjCBool : CustomStringConvertible {
 #endif
 
 internal class __NSCFType : NSObject {
-    private var _cfinfo : Int32
+    private var _cfinfo : _CFInfo
     
     override init() {
         // This is not actually called; _CFRuntimeCreateInstance will initialize _cfinfo
-        _cfinfo = 0
+        _cfinfo = _CFInfo(typeID: 0)
     }
     
     override var hash: Int {
-- 
2.17.1

